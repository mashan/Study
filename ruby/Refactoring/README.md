リファクタリング
================

What
---

* リファクタリングは、設計のよいコードに直していく作業
* 機能を追加しやすい構造になっていないプログラムに追加が発生した場合、リファクタリングをして作業をしやすくしたうえで追加する事
* リファクタリングを始める前に、テストスイートを用意する事


適用箇所発見の指針
-----------------

### コードの重複

* 同じ構造のコードを発見したら統一する方法を探す
    * メソッドの抽出
    * メソッドの上位階層への移動
    * テンプレートメソッドの作成
    * アルゴリズムの変更
    * サンドイッチメソッドの抽出
    * クラスの抽出
    * モジュールの抽出

### 長いメソッド

* 短いメソッドを集めたものにする
    * メソッドの抽出
    * 一時変数から問い合わせメソッドへ
    * 一時変数からチェインへ
    * 引数オブジェクトの導入
    * オブジェクト自体の受け渡し
    * メソッドからメソッドオブジェクトへ
    * 条件分の分解
    * ループからコレクションクロージャメソッドへ

### 大きなクラス

* 一つのクラスがしようとしている事が多すぎる場合は、インスタンス変数が多い
* 上記の場合、コードの重複がある
* いくつかの変数をまとめる 
    * クラスの抽出
    * サブクラスの抽出
    * モジュールの抽出

### 長い引数リスト

* メソッドには、必要なすべての情報を入集するために最低限必要な情報だけを渡せば良い
* メソッドが必要とするものの多くはメソッドのホストクラスにある

* 既知のオブジェクトに要求を発行するだけで、ひとつの引数から必要なデータが得られるとき
    * 引数からメソッドへ
* オブジェクトから集めたデータを引数として使っている場合
    * オブジェクト自体の受け渡し
* 論理的にオブジェクトにまとめられないような複数のデータ項目を引数としている場合
    * 引数オブジェクトの導入

### 変更系統の分岐

* 

### ショットガン創の手術

* 一つの種類の変更をしようとするたびに、様々なクラスに無数の小さな変更を加えなければいけない時
* 全ての変更点が一つのクラスにまとまるようにする
    * メソッドの移動
    * フィールドの移動
* いまあるクラスの中に適切な候補がなければ、新しいクラスを作る
    * クラスのインライン化

### メソッドの浮気

* 自分の所属クラス以外のクラスにやたらと関心を持っているように見える場合
* 関心を持っているクラスへの移動
    * メソッドの移動
* メソッドの一部だけが浮気している
    * メソッドの抽出 & その部分をメソッドの移動

### 群れたがるデータ

* 連れ立って行動する一連のデータは、それら専用のクラスを持つようにした方が良い
    * インスタンス変数の塊が現れている箇所を探す
    * 上記に対して「クラスの抽出」
    * 次に、メソッドシグネチャに注目、「引数オブジェクトの導入」「オブジェクト自体の受け渡し」を使ってスリム化

### プリミティブ強迫症

* 小さなオブジェクトを小さな仕事のために使った方がオブジェクト指向の恩恵にあやかれる
    * 「データ値からオブジェクトへ」
* タイプコードによって決まる条件のある時
    * タイプコードからポリモーフィズムへ
    * タイプコードからモジュールのextendへ
    * タイプコードからState/Strategyへ
* 配列を分解している
    * 配列からオブジェクトへ

### case文

* case文を見かけたら、ポリモーフィズムの適用を考える
    * 「メソッドの抽出」を使ってcase文を抽出
    * 次に「メソッドの移動」を使ってポリモフィズムを必要とするクラスにメソッドを移動
    * そして、「タイプコードからポリモーフィズムへ」「タイプコードからモジュールのextendへ」「タイプコードからState/Strategyへ」のどれかを使う

### パラレルな継承階層

* あるクラスのサブクラスを作るたびに、別のクラスのサブクラスも作らなければならなくなる事を言う
    * あるクラス階層のクラス名に付けられているプレフィックスと別のクラス階層で使われているプレフィックスが同じなら怪しい
* 重複を取り除く
    * 片方の階層のインスタンスがもう片方の階層のインスタンスを参照するようにする
    * そして、メソッドの移動、フィールドの移動を使う

### 仕事をしないクラス

* 仕事をしていないサブクラスやモジュールがあるとき
    * 「階層構造の結合」
    * ほとんど役にたたないコンポーネントは、「クラスのインライン化」「モジュールのインライン化」

### 空論的一般化


### 一時フィールド

* 特定の条件を満たしていなければインスタンス変数に値が与えられないオブジェクトは分かりにくい
    * 「クラスの抽出」を使って、変数の家を作る。変数に関連する全てのコードもコンポーネントに入れる
    * 「nullオブジェクトの導入」を使えば、変数が無効なときのためのコンポーネント作って、条件分岐を除去できる
    * 

### メッセージの連鎖

* クライアントがオブジェクトに別のオブジェクトを返すよう要求する、という事が連続するとき
* クライアントがナビゲーションの構造と密結合になる
    * 「委譲の隠蔽」を利用。しかし、使い過ぎると「横流しブローカー」の中間オブジェクトばかりになるため注意
    * 最終的なオブジェクトが何のために使われるのかを考える
        * 最終的なオブジェクトを使うコードに対して「メソッドの抽出」を適用出来るかを検討、「メソッドの移動」を使って連鎖を短縮

### 横流しブローカー

* クラスのインターフェイスの多くが、他のクラスに処理を委ねている場合は注意
    * 「横流しブローカーの除去」を使って、何が行われるかを実際にしっているオブジェクトとやり取りをする


### 親密すぎるクラス

* 2つのクラスが親しくなりすぎて、それぞれのプライベートな部分に踏み込んでいる場合
* 分ける
    * 「メソッドの移動」
    * 「フィールドの移動」
    * 「双方向リンクから片方向リンクへ」
    * 「クラスの抽出」
    * 「委譲の隠蔽」
    * 「っ継承から委譲へ」


### インターフェイスの異なるクラス群


### 不完全なライブラリクラス


### データクラス

* 属性だけを持っているクラスは、他のクラスから隅々まで操作されることを意味する
* 変更されてはいけないインスタンス変数
    * 「設定メソッドの削除」
* コレクションのインスタンス変数がある場合
    * 適切にカプセル化されているかを確認、されてない場合は「コレクションのカプセル化」を行う
* 他のクラスがゲッター/セッターメソッドを使っている箇所
    * 「メソッドの抽出」を使い、移動できるメソッドを作る

### 継承した遺産の拒絶


テストの構築
------------

### テストの追加

* クラスが実行すべきすべてのことに注目して、一つ一つに処理について、クラスが失敗しそうなあらゆる条件をテスト
* テストするか否かはリスクによって決める
* 現在、そして将来に現れそうなバグを見つける
* 踏み越えると問題が起きる境界条件について考え、そこに集中
* 予想通りに問題が置きて例外が生成される事



カタログ
-------

### 
#### メソッドの抽出

* 長いメソッドを分割して、部品をより適切なクラスへと移す
* コードの重複を減らす
* 安全な抽出
    * 新メソッドにスコープが限られる変数を元のコードから探す


#### メソッドの移動

* 所属しているクラスの情報を使ってないメソッドがいた場合、所属するオブジェクトが間違っていないかを疑う
* 移動後
    * メソッド名の調整
    * 引数を取り除く


#### 一時変数から問い合わせメソッドへ

* 不要な一時変数を取り除き、問い合わせを行う
* 一時変数は長くて複雑なルーチンが作られることを助長する
* パフォーマンスの懸念は、問題になった時に考えれば良い
* 冪等性が担保されていることには要注意


#### ループからコレクションクロージャメソッドへ

* 以下の様なテクニックを使うことで分量を減らせる
`@arays.inject(0) { |sum, element| sum + rental.charge }`


#### 他のオブジェクトの属性に基づいてcase文を書かない

* 自分自身のデータに基づいて実施
* 参照元情報に変更があった際、影響を見逃す可能性がある
* 以下の様な場合は、Hogeクラスにfirst?があるべき


    class Hoge
      FIRST = 1
      SECOND = 2
    end

    class Fuga
      def first?(num)
        case num
        when Hoge::Firest
          return true
        else
          return false
        end
      end
    end


#### ポリモーフィズム

* 同一メソッド名の挙動をオブジェクト毎に変化させる


#### タイプコードからState/Strategyへ

* やり方
    1. タイプコードに「自己カプセル化フィールドを適用」
    1. タイプコードを使う際には、必ずゲッター/セッターメソッドを経由する


#### モジュールの抽出

* 複数サブクラス間でメソッドの挙動を変えたい場合、モジュールにメソッドを定義してincludeし、例外の挙動を起こすクラスに別実装


### データの構成
#### 自己カプセル化フィールド

* フィールドアクセスに関して、以下２つの考え方がある
    * 直接変数アクセス
        * 変数が定義されているクラス内では、自由に変数にアクセスできるようにすべきというもの
        * シンプル
    * 関節変数アクセス
        * 同じクラス内でも、かならずアクセッサを使うべき
        * データの管理方法に柔軟性が生まれる。サブクラスでは、変数アクセスをオーバーライドしたい時など

#### データ値からオブジェクトへ

* 単純だと考えていたデータ項目が、それほど単純では無くなった際に行う

#### 値から参照へ

* オブジェクトを参照オブジェクトと値オブジェクトに分類すると役に立つ
    * 参照オブジェクト
        * 個々のオブジェクトは実世界の一つのオブジェクトを表している
        * 顧客や口座など
        * オブジェクトが等しいは、オブジェクトが同一かによって判断
    * 値オブジェクト
        * データ値によって定義される
        * 日付や金額など
        * コピーがあっても構わない

#### 参照から値へ

* 参照オブジェクトの操作が面倒になってきた時
* 特に分散/並行処理システムでは値オブジェクトの方が便利
* イミュータブル(どれか一つのオブジェクトに問い合わせた時に、かならず同じ結果が返さなければならない)にすること

#### 配列からオブジェクトへ

* Arrayが複数の異なるものを格納するために使われている時に利用
* 第一要素は人名、第二要素は…というルールは覚えにくいため


#### ハッシュからオブジェクトへ

* 名前付き引数以外では、同種のオブジェクトのコレクションを格納するときのみ利用

#### コレクションのカプセル化

* コレクションを公開するときに利用



