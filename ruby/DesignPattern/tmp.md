# Rubyによるデザインパターン
## 目的
* 適切な設計が出来るようになりたい
* デザインパターンの基礎を抑え、共通言語を得る

## 序
### 疑問
* オブジェクト同士はどのように関連しあうのか？結びつくべきなのか？
* それらは互いの何を知るべきなのか？
* 頻繁に変わりそうな部分を入れ替えるにはどうすればよいのか？

### 疑問への回答要点
* 変わるものを変わらないものから分離する
    * 理想的なシステムではすべての変更は局所的になる
* インターフェースに対してプログラムし、実装に対して行わない
    * 抽象化。「可能な限り一般的な型に対してプログラミングせよ」という意味。
    * 車インスタンスを作りたい場合、「車クラス」を作るのではない。「乗り物クラス」、「稼働クラス」を作る。
* 継承より集約
    * あるクラスに機能が必要になった際、スーパークラスに安易に実装するのではなく、別のクラスとして切り出す事を検討する
    * 例::Carクラスにエンジンスタート/ストップが必要になった
        * Carクラスだけでなく、他のクラスにも欲しい機能 => Vehicleに実装する？
        * エンジンを持たない乗り物も存在するし、Carに筒抜け
        * Engineとして切り出す！
* 委譲！！
    * 他のクラスに処理を任せてしまう
    * 柔軟性に富む実装になる
* 必要になるまで作らない


### 紹介される14のパターン

|pattern | 用途|
|-|-|
|Template Method | パターンによって問題解決したいとき|
|Strategy        | テクニックやアルゴリズムをラップ|
|Observer        | クラスAとクラスBを通信させたい時|
|Composite       | オブジェクトのコレクション自体が、そこに含まれる個々オブジェクトにおように見えるコレクションが必要なとき|
|Iterator        | オブジェクトのコレクションを隠し過ぎたくないとき|
|Command         | 指示をラップしたいとき|
|Adapter         | 目的の操作を達成できるオブジェクトが存在するが、インターフェースがふさわしくないとき|
|Proxy           | 目的のオブジェクトが存在するが、遠くにある場合|
|Decorator       | オブジェクトの責務を増やしたいとき|
|Singleton       | 唯一のインスタンスであって欲しい時|
|Factory Method  | |
|Abstract Factory| 矛盾の無い一連のオブジェクトを作る|
|Builder         | とても複雑で組み立てるのに特別なコードが要求されるオブジェクトが必要なとき。|
|Interpreter     | 問題を解決するにあたって間違ったPG言語を使っている感覚を持った時|


## Ruby復習
* rubyではすべてがオブジェクト
* シンボルはイミュータブルな文字列に使う
* Class
    * Class名は大文字から始める。rubyにおいて大文字から始まる変数は定数であり、Classは定数
    * ゲッター/セッター
        * attr_accessor : インスタンス変数を返すメソッド、及びインスタンス変数に新しい値を代入するメソッドを作り出す
        * attr_reader : インスタンス変数の読み込みのみを許可するメソッドを用意する
    * 一つの親クラス、スーパークラスしか持てない。スーパークラスを定義しない場合、Objectクラスのサブクラスになる
    * インスタンス変数は継承ツリーの上下に公開されている
    * super => スーパークラスから自分と同じメソッド名を持ったものを見つけて、呼び出す

## デザインパターン詳細
### Template Method
* アルゴリズムの一部に変化を与えたい時に有効
* 基底クラスには不変の部分を記述、変わる部分にはサブクラスに定義するメソッドにカプセル化する
* 他のパターンでも現れる、基本的なオブジェクト思考技術
* 継承を元にTemplate Methodが成り立っている事が欠点を生む点に注意
    * スーパークラスに大きく依存
    * 一度方針を決めると、それを変えることが困難


 
